GIT Cheat seat

- Delete commit
		git rebase -i <hashID>
		 >> drop <hashID> "commitOfHashID"
		 >>:wq
		git push -f

- Merge Commit
		git rebase -i HEAD~<number commit from latest commit>
		>>pick <hashID> "commitOfHashID first"
		     squash<hashID> "commitOfHashID second"
		     squash <hashID> "commitOfHashID third"
		      --------- n we want 
		>>:wq
		>> Comment all and just save one of the commits we want, we can edit it too
		>>:wq
		>>git push -f
		(*)  if rebase fail 
		git rebase --abort: cancel rollback
		git rebase --continue: continue rebase 
		git rebase --kip: kip the rebase process
		
- Roll back to exactly the hashID commit
                    git reset --hard <hashID status we want in history>
		 git push -f
		
- Revert commit (note: it will create one commit to remove)
		git revert <hashID commit>
		
- Reset commit (another way to back the status commit but we need to check the number of commits from the last to the status hashID we want)
	- git  reset --mixed ^HEAD~  || ^HEAD~1 (reset one commit)
	- git  reset --mixed | ^HEAD~<number of commits> (reset n commit to the hasID we want)
	(*) --mixed: reset but kip all in staging
	      --soft: reset but remove in staging kip all in before stag
	      --hard: remove all file changes (be careful using this)
		
	         
		rebase - How to squash all git commits into one? - Stack Overflow
		
		version control - Git: How to squash all commits on branch - Stack Overflow
		
		(1089) best solution
```
git checkout yourBranch
git reset $(git merge-base <parentBranch> $(git branch --show-current))
git add .
git commit -m "all in one"
```
		The orther ways
		(204) merge all commits in the branch in one line 204
			git rebase -i master(maybe the root branch u create from)
			          git rebase -i <parent branch>
			          git add .
			          git commit -m "all in one"
			           git push -f
			
		(625) git reset --soft <parent branch>
			            git add .
			            git commit -m "all in one"
			             git push -f